<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<meta name="theme-color" content="#0b0b0f"/>
<link rel="manifest" href="manifest.webmanifest"/>
<title>Backgammon TV v12.1 â€” Ø«Ø§Ø¨ØªØ© Ø¹Ù„Ù‰ Ø§Ù„ØªÙ„ÙØ²ÙŠÙˆÙ†</title>
<style>
:root{
  --bg:#0e0b10; --wood1:#3b2a1f; --wood2:#6c4b32; --triA:#c49a6c; --triB:#7a5030;
  --white:#f4f4f4; --black:#1a1a1a; --gold:#ffd166; --teal:#22d3ee; --green:#3ddc84; --panel:#141922; --edge:#283141;
}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;background:var(--bg);color:#eef4fb;font-family:system-ui,Segoe UI,Roboto,Ubuntu;overflow:hidden}
.header{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:linear-gradient(90deg,#171721,#121219);border-bottom:1px solid #232433}
.header h1{margin:0;font-size:18px}
.sub{color:#b7c4d1;font-size:12px}
.container{position:relative;height:calc(100% - 50px);min-height:240px}
canvas{width:100%;height:100%;display:block;touch-action:none;background:#0a0a0a}
#hint{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0008;color:#fff;z-index:80}
#hint .box{background:#111a25;border:1px solid #2b3140;padding:14px 16px;border-radius:12px}
#gear{position:fixed;right:12px;top:58px;z-index:60;background:#1f2430;border:1px solid #2b3140;color:#fff;border-radius:12px;padding:8px 12px;cursor:pointer}
#rollFab{position:fixed;left:12px;top:58px;z-index:60;background:#1f2430;border:1px solid #2b3140;color:#fff;border-radius:12px;padding:8px 12px;cursor:pointer;min-width:180px}
#panel{position:fixed;inset:0 0 0 auto;width:min(460px,92vw);background:#131720;border-left:1px solid #283141;z-index:70;transform:translateX(100%);transition:transform .25s;padding:14px;display:flex;flex-direction:column;gap:10px}
#panel.show{transform:translateX(0)}
.row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.row button,.row select,.row input[type=radio]+label{background:#1f2430;color:#fff;border:1px solid #2b3140;border-radius:10px;padding:6px 10px;cursor:pointer;font-size:13px}
.row input[type=radio]{display:none}
.row input[type=radio]:checked+label{outline:2px solid #3ddc84}
.group h4{margin:.4em 0}
.status{position:fixed;left:10px;bottom:10px;background:#111620a8;padding:6px 10px;border-radius:10px;font-size:12px;color:#cfe6ff;display:flex;gap:10px;flex-wrap:wrap;max-width:78vw}
.pill{background:#0f1420;border:1px solid #283141;padding:4px 8px;border-radius:8px}
.footer{position:fixed;inset:auto 0 6px 0;text-align:center;font-size:12px;color:#9fb0c0;opacity:.9;pointer-events:none}
.footer span{background:#0e1422cc;border:1px solid #283141;padding:4px 8px;border-radius:8px}
#err{position:fixed;inset:auto 10px 10px 10px;background:#2a1120;color:#ffdede;border:1px solid #553;text-shadow:0 1px 0 #000;padding:8px;border-radius:10px;font-size:12px;display:none;z-index:90}
@media (max-height:540px){ .header{display:none} .container{height:100%} }
</style>
</head>
<body>
<header class="header">
  <h1>ğŸ² Backgammon TV v12.1</h1>
  <div class="sub">Ø±ÙŠÙ…ÙˆØª: â† â†’ Ù„Ù„ØªÙ†Ù‚Ù„ØŒ Enter Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±ØŒ â†‘ Ù„Ù„Ø¨Ø§Ø±/Ø§Ù„Ø®Ø±ÙˆØ¬ØŒ Space/OK Ù„Ù„Ø²Ù‡Ø±ØŒ M Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©</div>
</header>

<button id="gear">âš™ï¸ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
<button id="rollFab">ğŸ² Ø±Ù…ÙŠ Ø§Ù„Ø²Ù‡Ø± â€” <span id="rollTxt">â€”</span></button>

<aside id="panel" aria-label="Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©">
  <div class="row" style="justify-content:space-between"><h3 style="margin:0">Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h3><button id="closePanel">âœ–</button></div>
  <div class="group">
    <h4>Ø§Ù„ÙˆØ¶Ø¹</h4>
    <div class="row">
      <input id="modePVP" type="radio" name="mode" value="pvp" checked><label for="modePVP">Ù„Ø§Ø¹Ø¨Ø§Ù†</label>
      <input id="modeAI" type="radio" name="mode" value="ai"><label for="modeAI">Ø¶Ø¯ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</label>
      <input id="modeAIAI" type="radio" name="mode" value="ai-ai"><label for="modeAIAI">Ù…ØªÙØ±Ù‘Ø¬ (ÙƒÙ…Ø¨ÙŠÙˆØªØ±Ã—ÙƒÙ…Ø¨ÙŠÙˆØªØ±)</label>
    </div>
  </div>
  <div class="group">
    <h4>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù„Ø¹Ø¨ (Variant)</h4>
    <div class="row">
      <select id="variant">
        <option value="std" selected>Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ© (Backgammon)</option>
        <option value="narde31">31 / Narde (Ø¨Ø¯ÙˆÙ† Ø¶Ø±Ø¨)</option>
        <option value="plakoto">Plakoto (Ù…Ø­Ø¨ÙˆØ³Ø© Ù…Ø¨Ø³Ø·Ø©)</option>
      </select>
    </div>
  </div>
  <div class="group">
    <h4>Ø§Ù„Ø±ØµÙ‘Ø©</h4>
    <div class="row">
      <button id="stdRassa">Ø§Ù„Ø±ØµÙ‘Ø© Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ©</button>
      <button id="rassa31">Ø±ØµÙ‘Ø© 31 (ÙƒÙ„ 15 Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø¡)</button>
      <button id="editRassa">ØªØ­Ø±ÙŠØ± ÙŠØ¯ÙˆÙŠ</button>
      <button id="clearBoard">ØªÙØ±ÙŠØº Ø§Ù„Ù„ÙˆØ­</button>
    </div>
    <div id="editBar" style="display:none">
      <div class="row"><span class="pill">ØªØ­Ø±ÙŠØ±: Ø§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø«Ù… "Ø¥Ø¶Ø§ÙØ©/Ø¥Ø²Ø§Ù„Ø©" Ø­Ø¬Ø± (Enter ÙŠØ¶ÙŠÙØŒ 0 ÙŠØ²ÙŠÙ„)</span></div>
      <div class="row">
        <input id="clrW" type="radio" name="clr" value="W" checked><label for="clrW">Ø£Ø¨ÙŠØ¶</label>
        <input id="clrB" type="radio" name="clr" value="B"><label for="clrB">Ø£Ø³ÙˆØ¯</label>
        <button id="addHere">Ø¥Ø¶Ø§ÙØ©</button>
        <button id="remHere">Ø¥Ø²Ø§Ù„Ø©</button>
        <button id="finishEdit" style="background:#0b5; border-color:#0b5">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ­Ø±ÙŠØ±</button>
      </div>
      <div class="row">
        <span id="remainW" class="pill">Ø£Ø­Ø¬Ø§Ø± Ø§Ù„Ø£Ø¨ÙŠØ¶: 15</span>
        <span id="remainB" class="pill">Ø£Ø­Ø¬Ø§Ø± Ø§Ù„Ø£Ø³ÙˆØ¯: 15</span>
      </div>
    </div>
  </div>
  <div class="group">
    <h4>Ø¹Ø§Ù…</h4>
    <div class="row">
      <button id="newBtn">Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯</button>
      <button id="fsBtn">â›¶ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©</button>
    </div>
  </div>
  <div class="row"><div class="pill">ØªÙ„Ù…ÙŠØ­ ØªÙ„ÙØ²ÙŠÙˆÙ†: Ø²Ø± <b>M</b> Ù„ÙØªØ­/Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.</div></div>
</aside>

<main class="container">
  <canvas id="cv"></canvas>
  <div id="hint"><div class="box">Ø§Ø¶ØºØ· Ø£ÙŠ Ø²Ø± Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„ØµÙˆØª. Space/OK Ù„Ø±Ù…ÙŠ Ø§Ù„Ø²Ù‡Ø±.</div></div>
  <div class="status">
    <span id="turn" class="pill">Ø§Ù„Ø¯ÙˆØ±: Ø£Ø¨ÙŠØ¶</span>
    <span id="dice" class="pill">Ø§Ù„Ø²Ù‡Ø±: â€”</span>
    <span id="msg"  class="pill">Ø¬Ø§Ù‡Ø²</span>
  </div>
</main>
<div class="footer"><span>Ø¨Ø±Ù…Ø¬Ø©: Ø£Ø­Ù…Ø¯ Ù…Ø¨Ø±ÙˆÙƒ</span></div>
<div id="err"></div>

<script>
(function(){
'use strict';
const $ = (id)=>document.getElementById(id);
const showErr = (m)=>{ const e=$('err'); e.style.display='block'; e.textContent = 'âš ï¸ Ø®Ø·Ø£: '+m; console.error(m); };

// Polyfills
window.requestAnimationFrame = window.requestAnimationFrame || function(cb){ return setTimeout(()=>cb(Date.now()),16); };

// Register SW (fail-safe)
if('serviceWorker' in navigator){ window.addEventListener('load', ()=> navigator.serviceWorker.register('sw.js').catch(()=>{})); }

// ===== Audio & TTS (safe) =====
let AC,sndMove,sndDice,sndHit,sndErr;
function audioInit(){ try{
  if(AC) return;
  const C = window.AudioContext || window.webkitAudioContext;
  if(!C) return;
  AC=new C();
  const blip=(f=440,d=.08,v=.28,t='sine')=>{ try{
    const o=AC.createOscillator(),g=AC.createGain();o.type=t;o.frequency.value=f;g.gain.value=v;o.connect(g).connect(AC.destination);o.start();g.gain.exponentialRampToValueAtTime(0.0001,AC.currentTime+d);o.stop(AC.currentTime+d);
  }catch{} };
  const noise=(d=.09,v=.30)=>{ try{
    const b=AC.createBuffer(1,AC.sampleRate*d,AC.sampleRate);const a=b.getChannelData(0);for(let i=0;i<a.length;i++) a[i]=(Math.random()*2-1)*Math.exp(-i/a.length);const s=AC.createBufferSource(),g=AC.createGain();g.gain.value=v;s.buffer=b;s.connect(g).connect(AC.destination);s.start();
  }catch{} };
  sndMove=()=>{ blip(380,.08,.26,'square'); };
  sndDice=()=>{ for(let i=0;i<5;i++) setTimeout(()=>noise(.05,.24), i*45); };
  sndHit =()=>{ blip(220,.12,.32,'sawtooth'); };
  sndErr =()=>{ blip(160,.12,.35,'sine'); };
}catch(e){ showErr(e.message); } }
function enableAudioOnce(){ try{ $('hint').style.display='none'; audioInit(); }catch(e){ showErr(e.message); } }

function speak(text,lang){ try{
  if(!('speechSynthesis' in window) || !('SpeechSynthesisUtterance' in window)) return;
  const u=new SpeechSynthesisUtterance(text); if(lang) u.lang=lang; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
}catch(e){ /* ignore */ } }
function diceNameArabic(a,b){
  const map={1:'ÙŠÙÙƒ',2:'Ø¯ÙÙˆ',3:'Ø³ÙÙ‡',4:'Ø¬Ù‡Ø§Ø±',5:'Ø¨ÙŠØ´',6:'Ø´ÙŠØ´'};
  const doubles={1:'Ù‡Ø§Ø¨ ÙŠÙÙƒ',2:'Ø¯ÙˆØ¨Ø§Ø±Ø©',3:'Ø¯ÙˆØ³ÙŠÙ‡',4:'Ø¯ÙˆØ±Ø¬ÙŠ',5:'Ø¯ÙØ¨ÙØ´',6:'Ø¯ÙØ´Ù‘ÙØ´'};
  if(a===b) return doubles[a]||('Ø¯Ø¨Ù„ '+a);
  const hi=Math.max(a,b), lo=Math.min(a,b);
  if(hi===6 && lo===5) return 'Ø´ÙŠØ´-Ø¨ÙŠØ´';
  return (map[hi]||hi)+' - '+(map[lo]||lo);
}
function diceNameEnglish(a,b){ const en=['','one','two','three','four','five','six']; if(a===b) return en[a]+' and '+en[b]; const hi=Math.max(a,b), lo=Math.min(a,b); return en[hi]+'-'+en[lo]; }

// ===== Game State =====
const cv=$('cv'); const ctx=cv.getContext('2d');
if(!ctx){ showErr('Canvas ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…'); return; }
let W=0,H=0, boardRect=null;
const WHITE=0, BLACK=1; let turn=WHITE;
let points=new Array(24).fill(null).map(_=>({n:0, owner:null, pin:null}));
let bar=[0,0], off=[0,0];
let dice=[], diceLeft=[];
let focus=23; let selected=null;
let mode='pvp'; let variant='std';
let editMode=false; let editColor=WHITE; let remain=[15,15];
const turnEl=$('turn'), diceEl=$('dice'), msgEl=$('msg'), rollTxt=$('rollTxt');

// ===== Setup / Rassa =====
function setPoint(i, owner, count){ const p=points[i]; p.owner=owner; p.n=count; p.pin=null; }
function updateRemainUI(){ $('remainW').textContent='Ø£Ø­Ø¬Ø§Ø± Ø§Ù„Ø£Ø¨ÙŠØ¶: '+remain[WHITE]; $('remainB').textContent='Ø£Ø­Ø¬Ø§Ø± Ø§Ù„Ø£Ø³ÙˆØ¯: '+remain[BLACK]; }
function showEditBar(v){ $('editBar').style.display= v? 'block':'none'; }
function clearBoard(){ points.forEach(p=>{p.n=0;p.owner=null;p.pin=null;}); bar=[0,0]; off=[0,0]; selected=null; msgEl.textContent='ØªÙ… ØªÙØ±ÙŠØº Ø§Ù„Ù„ÙˆØ­.'; drawAll(); }
function standardRassa(){ try{
  points.forEach(p=>{p.n=0;p.owner=null;p.pin=null;}); bar=[0,0]; off=[0,0]; selected=null; editMode=false;
  setPoint(23,WHITE,2); setPoint(12,WHITE,5); setPoint(7,WHITE,3); setPoint(5,WHITE,5);
  setPoint(0,BLACK,2); setPoint(11,BLACK,5); setPoint(16,BLACK,3); setPoint(18,BLACK,5);
  remain=[0,0]; updateRemainUI(); msgEl.textContent='Ø±ØµÙ‘Ø© Ù‚ÙŠØ§Ø³ÙŠØ©. Space/OK Ù„Ù„Ø²Ù‡Ø±.'; drawAll();
}catch(e){ showErr(e.message); } }
function rassa31(){ try{
  points.forEach(p=>{p.n=0;p.owner=null;p.pin=null;}); bar=[0,0]; off=[0,0]; selected=null; editMode=false;
  setPoint(23,WHITE,15); setPoint(0,BLACK,15); remain=[0,0]; updateRemainUI(); msgEl.textContent='Ø±ØµÙ‘Ø© 31: Ø¨Ø¯ÙˆÙ† Ø¶Ø±Ø¨. Space/OK Ù„Ù„Ø²Ù‡Ø±.'; drawAll();
}catch(e){ showErr(e.message); } }
function startEdit(){ clearBoard(); editMode=true; remain=[15,15]; editColor=WHITE; updateRemainUI(); showEditBar(true); msgEl.textContent='ØªØ­Ø±ÙŠØ±: Ø§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø«Ù… "Ø¥Ø¶Ø§ÙØ©" Ù„ÙˆØ¶Ø¹ Ø­Ø¬Ø±.'; }
function finishEdit(){ editMode=false; showEditBar(false); msgEl.textContent='ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ­Ø±ÙŠØ±. Space/OK Ù„Ù„Ø²Ù‡Ø±.'; }
function addHere(){ if(!editMode) return; const idx=focus==='BAR'||focus==='OFF'? (editColor===WHITE?23:0):focus; if(remain[editColor]<=0){ msgEl.textContent='Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø­Ø¬Ø§Ø± Ù…ØªØ¨Ù‚ÙŠØ©.'; return; } const p=points[idx]; if(p.n===0){ p.owner=editColor; p.n=1; } else if(p.owner===editColor){ p.n++; } else { p.owner=editColor; p.n=1; p.pin=null; } remain[editColor]--; updateRemainUI(); drawAll(); }
function remHere(){ if(!editMode) return; const idx=focus==='BAR'||focus==='OFF'? (editColor===WHITE?23:0):focus; const p=points[idx]; if(p.n>0){ p.n--; if(p.n===0) p.owner=null; remain[editColor]++; updateRemainUI(); drawAll(); } }

// ===== Dice =====
function rollDice(){
  try{
    enableAudioOnce(); sndDice && sndDice();
    const d1=1+Math.floor(Math.random()*6), d2=1+Math.floor(Math.random()*6);
    dice = (d1===d2)? [d1,d1,d1,d1] : [d1,d2];
    diceLeft=[...dice]; selected=null;
    const nameAR=diceNameArabic(d1,d2), nameEN=diceNameEnglish(d1,d2);
    rollTxt.textContent = (d1===d2? (d1+'-'+d2+' (Ø¯Ø¨Ù„)') : (Math.max(d1,d2)+'-'+Math.min(d1,d2)));
    diceEl.textContent='Ø§Ù„Ø²Ù‡Ø±: '+diceLeft.join(',');
    msgEl.textContent='Ø§Ø®ØªØ± Ù…ØµØ¯Ø±Ù‹Ø§ Ø«Ù… Ø§Ù„ÙˆØ¬Ù‡Ø©.';
    speak(nameEN,'en-US'); setTimeout(()=>speak(nameAR,'ar'), 600);
    drawAll();
  }catch(e){ showErr(e.message); }
}
function useDie(val){ const i=diceLeft.indexOf(val); if(i>=0){ diceLeft.splice(i,1); diceEl.textContent='Ø§Ù„Ø²Ù‡Ø±: '+(diceLeft.length?diceLeft.join(','):'â€”'); return true; } return false; }

// ===== Movement & Rules =====
function dirOf(p){ return p===WHITE? -1:+1; }
function isHomeAll(p){
  if(p===WHITE){ for(let i=6;i<24;i++){ if(points[i].owner===WHITE && points[i].n>0) return false; } return bar[WHITE]===0; }
  else { for(let i=0;i<18;i++){ if(points[i].owner===BLACK && points[i].n>0) return false; } return bar[BLACK]===0; }
}
function entryPoint(p,d){ return (p===WHITE)? (24-d) : (d-1); }
function stepTo(p,from,d){
  const dir=dirOf(p), t=from+dir*d;
  if(p===WHITE && t<0){
    if(isHomeAll(WHITE)){ const need=from+1; if(d===need) return 'OFF';
      if(d>need){ for(let i=from+1;i<=5;i++){ if(points[i].owner===WHITE && points[i].n>0) return -1; } return 'OFF'; }
    } return -1;
  }
  if(p===BLACK && t>23){
    if(isHomeAll(BLACK)){ const need=24-from; if(d===need) return 'OFF';
      if(d>need){ for(let i=from-1;i>=18;i--){ if(points[i].owner===BLACK && points[i].n>0) return -1; } return 'OFF'; }
    } return -1;
  }
  return t;
}
function canLand_std(p,to){ const pt=points[to]; return (pt.owner===p || pt.owner===null || (pt.owner!==p && pt.n===1)); }
function canLand_narde(p,to){ const pt=points[to]; return (pt.owner===p || pt.owner===null); }
function canLand_plakoto(p,to){ const pt=points[to]; if(pt.owner===p || pt.owner===null) return true; if(pt.owner!==p && pt.n===1 && !pt.pin){ return true; } return false; }
function canLand(p,to){ if(variant==='std') return canLand_std(p,to); if(variant==='narde31') return canLand_narde(p,to); if(variant==='plakoto') return canLand_plakoto(p,to); return canLand_std(p,to); }
function anyMovesAvailable(p){
  const ds=[...diceLeft]; if(ds.length===0) return false;
  if(variant==='std' && bar[p]>0){ for(const d of ds){ const to=entryPoint(p,d); if(to>=0&&to<24 && canLand(p,to)) return true; } return false; }
  for(let i=0;i<24;i++){ if(points[i].owner===p && points[i].n>0){
    for(const d of ds){ const to=stepTo(p,i,d); if(to==='OFF'){ if(isHomeAll(p)) return true; } else if(to>=0 && canLand(p,to)) return true; }
  }}
  return false;
}
function legalFrom(p, from){
  const moves=[]; if(diceLeft.length===0) return moves;
  if(variant==='std' && from==='BAR'){ for(const d of [...new Set(diceLeft)]){ const to=entryPoint(p,d); if(to>=0&&to<24 && canLand(p,to)) moves.push({from,to,die:d}); } return moves; }
  if(from==='BAR') return moves;
  if(points[from].owner!==p || points[from].n===0) return moves;
  for(const d of [...new Set(diceLeft)]){
    const to=stepTo(p,from,d);
    if(to==='OFF'){ if(isHomeAll(p)) moves.push({from,to:'OFF',die:d}); }
    else if(to>=0 && to<24 && canLand(p,to)) moves.push({from,to,die:d});
  }
  return moves;
}
function applyMove(p, mv){
  if(mv.from==='BAR'){ bar[p]--; } else { points[mv.from].n--; if(points[mv.from].n===0) { points[mv.from].owner=null; points[mv.from].pin=null; } }
  if(mv.to==='OFF'){ off[p]++; useDie(mv.die); sndMove && sndMove(); return; }
  const dest=points[mv.to];
  if(variant==='std'){
    if(dest.owner!==p && dest.n===1){ dest.n=0; dest.owner=null; bar[1-p]++; sndHit && sndHit(); }
    if(dest.owner===null){ dest.owner=p; dest.n=1; } else { if(dest.owner!==p){} else dest.n++; }
  } else if(variant==='narde31'){
    if(dest.owner===null){ dest.owner=p; dest.n=1; } else { dest.n++; }
  } else if(variant==='plakoto'){
    if(dest.owner!==p && dest.n===1 && !dest.pin){ dest.pin = dest.owner; dest.owner = p; dest.n = 1; }
    else { if(dest.owner===null){ dest.owner=p; dest.n=1; } else if(dest.owner===p){ dest.n++; } }
  }
  useDie(mv.die); sndMove && sndMove();
}
function endTurnIfNeeded(){
  if(diceLeft.length===0 || !anyMovesAvailable(turn)){
    turn=1-turn; selected=null; dice=[]; diceLeft=[];
    msgEl.textContent='Ø±Ù…ÙŠ Ø§Ù„Ø²Ù‡Ø± (Space/OK)'; updateHud();
    if(mode==='ai-ai' || (mode==='ai' && turn===BLACK)){ setTimeout(()=>{ rollDice(); aiPlayTurn(); }, 400); }
  } else { selected=null; msgEl.textContent='Ø£ÙƒÙ…Ù„ Ù†Ù‚Ù„Ø§ØªÙƒ.'; }
}
function checkWin(){ if(off[WHITE]===15){ msgEl.textContent='ğŸ‰ ÙØ§Ø² Ø§Ù„Ø£Ø¨ÙŠØ¶!'; diceLeft=[]; return true; } if(off[BLACK]===15){ msgEl.textContent='ğŸ‰ ÙØ§Ø² Ø§Ù„Ø£Ø³ÙˆØ¯!'; diceLeft=[]; return true; } return false; }

// ===== Rendering =====
let geom=null;
function computeGeom(){
  const margin=20; const boardW=Math.max(320, innerWidth)-margin*2, boardH=Math.max(240, innerHeight)-margin*2 - ($('.header')?.offsetHeight||0);
  const x=margin,y=margin; boardRect={x,y,w:boardW,h:boardH};
  const pointW=boardW/12, pipH=Math.max(100,boardH*0.42);
  const pts=[];
  for(let k=0;k<12;k++){ const px=x+k*pointW; const idx=23-k; pts[idx]={x:px,y:y,w:pointW,h:pipH,top:true}; }
  for(let k=0;k<12;k++){ const px=x+k*pointW; const idx=k; pts[idx]={x:pts[idx]?.x??px,y:y+boardH,w:pointW,h:pipH,top:false}; }
  const barArea={x:x+boardW/2 - pointW*0.12/2,y:y,w:pointW*0.12,h:boardH};
  const offArea={x:x+boardW+10,y:y,w:140,h:boardH};
  geom={pts,barArea,offArea,pointW,pipH};
}
function drawBoard(){
  try{
    ctx.fillStyle='#0b0b0f'; ctx.fillRect(0,0,cv.width,cv.height);
    const g=ctx.createLinearGradient(0,0,cv.width,cv.height); g.addColorStop(0,'#3d2a1b'); g.addColorStop(1,'#6c4b32'); ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);
    ctx.fillStyle='#2b2118'; ctx.fillRect(boardRect.x,boardRect.y,boardRect.w,boardRect.h);
    for(let k=0;k<12;k++){ const px=boardRect.x+k*geom.pointW;
      tri(px,boardRect.y,geom.pointW,geom.pipH,(k%2===0)?'#c49a6c':'#7a5030',true);
      tri(px,boardRect.y+boardRect.h,geom.pointW,geom.pipH,(k%2===0)?'#7a5030':'#c49a6c',false);
    }
    ctx.fillStyle='#1a1310'; ctx.fillRect(geom.barArea.x,geom.barArea.y,geom.barArea.w,geom.barArea.h);
    ctx.fillStyle='#0f1420'; ctx.fillRect(geom.offArea.x,geom.offArea.y,geom.offArea.w,geom.offArea.h); ctx.strokeStyle='#283141'; ctx.strokeRect(geom.offArea.x,geom.offArea.y,geom.offArea.w,geom.offArea.h);
    if(dice.length||diceLeft.length){
      const vals = (diceLeft.length? diceLeft : dice);
      const cx = boardRect.x + boardRect.w/2, cy = boardRect.y + 8;
      let offx = -40;
      for(let i=0;i<Math.min(2, vals.length); i++){ drawDie(cx+offx, cy, 28, vals[i], i===0); offx += 80; }
    }
  }catch(e){ showErr('Ø±Ø³Ù… Ø§Ù„Ù„ÙˆØ­: '+e.message); }
}
function tri(x,y,w,h,c,top){ ctx.fillStyle=c; ctx.beginPath(); if(top){ ctx.moveTo(x,y); ctx.lineTo(x+w,y); ctx.lineTo(x+w/2,y+h);} else { ctx.moveTo(x,y); ctx.lineTo(x+w,y); ctx.lineTo(x+w/2,y-h);} ctx.closePath(); ctx.fill(); }
function drawDie(cx,cy,size,val,red=false){
  ctx.save(); ctx.translate(cx,cy); ctx.fillStyle= red? '#a52626' : '#e6e6e6';
  ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.fillRect(-size/2,0,size,size); ctx.strokeRect(-size/2,0,size,size);
  ctx.fillStyle='#000'; const s=size; const d=s/4; const p=(x,y)=>{ ctx.beginPath(); ctx.arc(x,y,3.7,0,Math.PI*2); ctx.fill(); };
  const map={1:[[0,s/2]],2:[[-d,s/2-d],[d,s/2+d]],3:[[-d,s/2-d],[0,s/2],[d,s/2+d]],4:[[-d,s/2-d],[d,s/2-d],[-d,s/2+d],[d,s/2+d]],5:[[-d,s/2-d],[d,s/2-d],[0,s/2],[-d,s/2+d],[d,s/2+d]],6:[[-d,s/2-d],[d,s/2-d],[-d,s/2],[d,s/2],[-d,s/2+d],[d,s/2+d]]};
  (map[val]||[]).forEach(([x,y])=>p(x,y)); ctx.restore();
}
function disc(x,y,r,fill,edge){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); const grad=ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.3,x,y,r); grad.addColorStop(0,fill); grad.addColorStop(1,edge); ctx.fillStyle=grad; ctx.fill(); ctx.strokeStyle=edge; ctx.lineWidth=2; ctx.stroke(); }
function drawCheckers(){
  for(let i=0;i<24;i++){
    const p=points[i]; if(p.n===0 && !p.pin) continue; const g=geom.pts[i];
    for(let k=0;k<p.n;k++){ const cx=g.x+g.w/2; const dir=g.top?1:-1; const cy=(g.top?g.y:g.y)+(g.top?10:-10)+dir*(k*(g.h*0.08)+26); disc(cx,cy,22,p.owner===WHITE?'#f4f4f4':'#1a1a1a',p.owner===WHITE?'#bbb':'#444'); }
    if(p.pin!==null){ const cx=g.x+g.w/2, cy=(g.top?g.y:g.y)+(g.top?10:-10)+ (g.top?1:-1)*8; ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#222'; ctx.stroke(); }
  }
  const bx=geom.barArea.x+geom.barArea.w/2;
  for(let k=0;k<bar[WHITE];k++){ disc(bx,boardRect.y+20+k*26,22,'#f4f4f4','#bbb'); }
  for(let k=0;k<bar[BLACK];k++){ disc(bx,boardRect.y+boardRect.h-20-k*26,22,'#1a1a1a','#444'); }
  ctx.fillStyle='#cfe6ff'; ctx.font='14px sans-serif'; ctx.fillText('Ø®Ø§Ø±Ø¬ (Ø£Ø¨ÙŠØ¶): '+off[WHITE], geom.offArea.x+12, geom.offArea.y+24);
  ctx.fillText('Ø®Ø§Ø±Ø¬ (Ø£Ø³ÙˆØ¯): '+off[BLACK], geom.offArea.x+12, geom.offArea.y+46);
}
function focusRect(){ if(focus==='BAR') return {x:geom.barArea.x,y:geom.barArea.y,w:geom.barArea.w,h:geom.barArea.h}; if(focus==='OFF') return {x:geom.offArea.x,y:geom.offArea.y,w:geom.offArea.w,h:geom.offArea.h}; const g=geom.pts[focus]; return {x:g.x,y:g.top?g.y:g.y-g.h,w:g.w,h:g.h}; }
function drawFocus(selectedMoves){
  if(selected && selected.from!=='BAR'){ const g=geom.pts[selected.from]; ctx.save(); ctx.strokeStyle='#ffd166'; ctx.lineWidth=4; ctx.strokeRect(g.x+4,(g.top?g.y:g.y-g.h)+4,g.w-8,g.h-8); ctx.restore(); }
  if(selectedMoves){ for(const m of selectedMoves){ if(m.to==='OFF'){ ctx.save(); ctx.globalAlpha=.2; ctx.fillStyle='#3ddc84'; ctx.fillRect(geom.offArea.x,geom.offArea.y,geom.offArea.w,geom.offArea.h); ctx.restore(); } else { const g=geom.pts[m.to]; ctx.save(); ctx.globalAlpha=.22; ctx.fillStyle='#3ddc84'; ctx.fillRect(g.x,g.top?g.y:g.y-g.h,g.w,g.h); ctx.restore(); } } }
  const r=focusRect(); if(r){ ctx.save(); ctx.strokeStyle='#22d3ee'; ctx.setLineDash([6,6]); ctx.lineWidth=3; ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.restore(); }
}
function drawAll(){ try{ cv.width=Math.max(320, window.innerWidth); cv.height=Math.max(240, window.innerHeight - ($('.header')?.offsetHeight||0)); computeGeom(); drawBoard(); drawCheckers(); drawFocus(selected?selected.legal:null); }catch(e){ showErr('drawAll: '+e.message); } }

// ===== Input =====
function ensureDice(){ if(diceLeft.length===0){ rollDice(); } }
function selectFrom(src){
  if(editMode){ focus=src==='BAR'||src==='OFF'?focus:src; drawAll(); return; }
  if(variant==='std'){ if(bar[turn]>0 && src!=='BAR'){ msgEl.textContent='Ø§Ø¯Ø®Ù„ Ù…Ù† Ø§Ù„Ø¨Ø§Ø± Ø£ÙˆÙ„Ù‹Ø§.'; sndErr && sndErr(); return; } }
  ensureDice();
  const legal=legalFrom(turn, src);
  if(legal.length===0){ msgEl.textContent='Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ù‚Ù„Ø§Øª Ù…Ù† Ù‡Ù†Ø§.'; sndErr && sndErr(); return; }
  selected={from:src, legal};
  if(legal.length===1){ tryPlaceTo(legal[0].to, legal[0].die); return; }
  msgEl.textContent='Ø§Ø®ØªØ± Ø§Ù„ÙˆØ¬Ù‡Ø© Ø«Ù… Enter'; drawAll();
}
function tryPlaceTo(target, dieOverride){
  if(editMode) return;
  if(!selected){ sndErr && sndErr(); return; }
  let mv = selected.legal.find(m=> (target==='OFF' && m.to==='OFF') || (m.to===target));
  if(!mv && dieOverride){ mv=selected.legal.find(m=> m.die===dieOverride && ((target==='OFF' && m.to==='OFF') || (m.to===target))); }
  if(!mv){ sndErr && sndErr(); return; }
  animateMove(selected.from, mv, ()=>{ if(checkWin()) return; endTurnIfNeeded(); drawAll(); });
}
function checkWin(){ if(off[WHITE]===15){ msgEl.textContent='ğŸ‰ ÙØ§Ø² Ø§Ù„Ø£Ø¨ÙŠØ¶!'; diceLeft=[]; return true; } if(off[BLACK]===15){ msgEl.textContent='ğŸ‰ ÙØ§Ø² Ø§Ù„Ø£Ø³ÙˆØ¯!'; diceLeft=[]; return true; } return false; }

function nextFocus(step){
  if(focus==='BAR' || focus==='OFF'){ focus = (turn===WHITE?23:0); return; }
  const order = (turn===WHITE)? [...Array(24).keys()].reverse() : [...Array(24).keys()];
  const idx = order.indexOf(focus); focus = order[(idx+step+24)%24];
}

// Keyboard / Remote
document.addEventListener('keydown', e=>{
  enableAudioOnce();
  const key=e.key||e.code||'';
  if(key==='m' || key==='M'){ togglePanel(); }
  if(key==='ArrowRight'){ nextFocus(+1); drawAll(); }
  if(key==='ArrowLeft'){  nextFocus(-1); drawAll(); }
  if(key==='ArrowUp'){ if(editMode){ /* ignore */ } else if(variant==='std' && bar[turn]>0){ focus='BAR'; } else if(isHomeAll(turn)){ focus='OFF'; } drawAll(); }
  if(key==='Enter' || e.keyCode===13){
    if(editMode){ addHere(); }
    else{
      if(!selected){ if(focus==='BAR') selectFrom('BAR'); else selectFrom(focus); }
      else{ if(focus==='OFF') tryPlaceTo('OFF'); else tryPlaceTo(focus); }
    }
    drawAll();
  }
  if(key===' ' || e.code==='Space'){ rollDice(); }
  if(key==='0'){ if(editMode) remHere(); }
});

cv.addEventListener('pointerdown', e=>{
  enableAudioOnce();
  const r=cv.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  const inRect=(R)=> x>=R.x && x<=R.x+R.w && y>=R.y && y<=R.y+R.h;
  if(geom && inRect(geom.barArea)){ if(!selected) selectFrom('BAR'); else { focus='BAR'; } drawAll(); return; }
  if(geom && inRect(geom.offArea)){ if(selected) { focus='OFF'; tryPlaceTo('OFF'); } drawAll(); return; }
  if(geom) for(let i=0;i<24;i++){
    const g=geom.pts[i]; const R={x:g.x,y:g.top?g.y:g.y-g.h,w:g.w,h:g.h};
    if(inRect(R)){
      focus=i;
      if(editMode){ drawAll(); return; }
      if(!selected) selectFrom(i); else { tryPlaceTo(i); }
      drawAll(); return;
    }
  }
});

// ===== Animation =====
function pointCenter(idx, ownerHint){
  if(idx==='BAR'){ const bx=geom.barArea.x+geom.barArea.w/2; const by=ownerHint===WHITE? boardRect.y+24 : boardRect.y+boardRect.h-24; return {x:bx,y:by}; }
  if(idx==='OFF'){ return {x:geom.offArea.x+geom.offArea.w/2, y: boardRect.y+boardRect.h/2}; }
  const g=geom.pts[idx]; const p=points[idx]; const count=(p.owner===ownerHint)? p.n : 0;
  const cx=g.x+g.w/2; const dir=g.top?1:-1; const cy=(g.top?g.y:g.y)+(g.top?10:-10)+dir*(count*(g.h*0.08)+26);
  return {x:cx,y:cy};
}
function animateMove(from, mv, done){
  const owner=turn; const s=(from==='BAR')? pointCenter('BAR',owner) : pointCenter(from,owner);
  const t=(mv.to==='OFF')? pointCenter('OFF',owner) : pointCenter(mv.to,owner);
  const T=300; const t0=performance.now();
  (function step(now){
    const tt=Math.min(1,(now-t0)/T); drawAll();
    const x=s.x+(t.x-s.x)*tt, y=s.y+(t.y-s.y)*tt;
    disc(x,y,23, owner===WHITE?'#f4f4f4':'#1a1a1a', owner===WHITE?'#bbb':'#444');
    if(tt<1) requestAnimationFrame(step); else { applyMove(owner,mv); done&&done(); }
  })(performance.now());
}

// ===== HUD / Layout / Panel =====
function updateHud(){ turnEl.textContent='Ø§Ù„Ø¯ÙˆØ±: '+(turn===WHITE?'Ø£Ø¨ÙŠØ¶':'Ø£Ø³ÙˆØ¯'); diceEl.textContent='Ø§Ù„Ø²Ù‡Ø±: '+(diceLeft.length?diceLeft.join(','):'â€”'); }
function resize(){ try{ drawAll(); }catch(e){ showErr('resize: '+e.message); } }
addEventListener('resize', resize);

const panel=$('panel');
function togglePanel(){ panel.classList.toggle('show'); }
$('gear').onclick=togglePanel;
$('closePanel').onclick=togglePanel;
$('fsBtn').onclick=()=>{ const el=document.documentElement; if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); } };
$('newBtn').onclick=()=>{ selected=null; dice=[]; diceLeft=[]; turn=WHITE; standardRassa(); };
$('rollFab').onclick=()=>{ rollDice(); };

// Modes & Variant
$('modePVP').onchange=e=>{ if(e.target.checked) mode='pvp'; };
$('modeAI').onchange=e=>{ if(e.target.checked){ mode='ai'; aiMaybeKick(); } };
$('modeAIAI').onchange=e=>{ if(e.target.checked){ mode='ai-ai'; aiMaybeKick(); } };
$('variant').onchange=e=>{ variant=e.target.value; msgEl.textContent='ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†Ù…Ø·: '+e.target.options[e.target.selectedIndex].text; };

function aiMaybeKick(){ if((mode==='ai' && turn===BLACK) || mode==='ai-ai'){ setTimeout(()=>{ rollDice(); aiPlayTurn(); }, 300); } }

// Rassa & Edit
$('stdRassa').onclick=()=>{ standardRassa(); };
$('rassa31').onclick=()=>{ rassa31(); };
$('editRassa').onclick=()=>{ startEdit(); };
$('clearBoard').onclick=()=>{ clearBoard(); };
$('clrW').onchange=e=>{ if(e.target.checked) editColor=WHITE; };
$('clrB').onchange=e=>{ if(e.target.checked) editColor=BLACK; };
$('addHere').onclick=()=>{ addHere(); };
$('remHere').onclick=()=>{ remHere(); };
$('finishEdit').onclick=()=>{ finishEdit(); };

// ===== Simple AI =====
function aiPlayTurn(){
  if(editMode) return;
  if(diceLeft.length===0) rollDice();
  const p=turn;
  for(let loop=0; loop<4; loop++){
    const all=[];
    if(variant==='std' && bar[p]>0){
      for(const d of [...new Set(diceLeft)]){ const to=entryPoint(p,d); if(to>=0&&to<24 && canLand(p,to)) all.push({from:'BAR',to,die:d}); }
    } else {
      for(let i=0;i<24;i++){
        if(points[i].owner===p && points[i].n>0){
          for(const d of [...new Set(diceLeft)]){
            const to=stepTo(p,i,d);
            if(to==='OFF'){ if(isHomeAll(p)) all.push({from:i,to:'OFF',die:d}); }
            else if(to>=0 && to<24 && canLand(p,to)) all.push({from:i,to,die:d});
          }
        }
      }
    }
    if(all.length===0) break;
    all.sort((A,B)=>{
      const score=(m)=>{
        const hit = (variant==='std' && m.to!=='OFF' && points[m.to].owner===1-p && points[m.to].n===1)? 50:0;
        const bear=(m.to==='OFF')?80:0; const dist=(m.from==='BAR')?0:Math.abs(m.to-m.from);
        return hit + bear + dist;
      };
      return score(B)-score(A);
    });
    const mv=all[0];
    applyMove(p, mv);
    drawAll();
    if(diceLeft.length===0) break;
  }
  setTimeout(()=>{ endTurnIfNeeded(); drawAll(); if((mode==='ai-ai') || (mode==='ai' && turn===BLACK)) setTimeout(()=>{ rollDice(); aiPlayTurn(); }, 500); }, 400);
}

// Boot
function boot(){
  try{
    drawAll();
    standardRassa();
  }catch(e){ showErr('boot: '+e.message); }
}
window.addEventListener('DOMContentLoaded', boot);

// First interaction enables audio
document.body.addEventListener('pointerdown', enableAudioOnce, {once:true});
document.body.addEventListener('keydown', ()=>enableAudioOnce(), {once:true});
})();
</script>
</body>
</html>
